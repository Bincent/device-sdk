; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\xlink_config.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\xlink_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I..\sdk\1.50\include -I..\xlink -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\xlink_config.crf ..\src\xlink_config.c]
                          THUMB

                          AREA ||i.XlinkConfigReadConfig||, CODE, READONLY, ALIGN=1

                  XlinkConfigReadConfig PROC
;;;45      */
;;;46     static int XlinkConfigReadConfig(x_int8 *retbuffer, unsigned int buflen) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;47     	//memcpy(retbuffer,buf,buflen);
;;;48     	x_int16 ret = hffile_userbin_read(XLINK_USR_BIN_ADDR_CFG, retbuffer, buflen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       hffile_userbin_read
000010  b206              SXTH     r6,r0
;;;49     	//int ret =buflen;
;;;50     	return ret;
000012  4630              MOV      r0,r6
;;;51     }
000014  bd70              POP      {r4-r6,pc}
;;;52     
                          ENDP


                          AREA ||i.XlinkConfigReset||, CODE, READONLY, ALIGN=1

                  XlinkConfigReset PROC
;;;168     */
;;;169    XLINK_FUNC void XlinkConfigReset(void) {
000000  4770              BX       lr
;;;170    //	char buf[XLINK_SIZE_17];
;;;171    //	xlink_memset(buf, 0, XLINK_SIZE_17);
;;;172    //	//XlinkConfigWriteConfig(XLINK_CONFIG_INDEX_DEVICE_ID, buf, XLINK_SIZE_17 - 1);
;;;173    //	XlinkConfigWriteConfig(0, buf, XLINK_SIZE_17 - 1);
;;;174    //	XlinkConfigWriteConfig(1, buf, XLINK_SIZE_17 - 1);
;;;175    //	XlinkConfigWriteConfig(2, buf, XLINK_SIZE_17 - 1);
;;;176    //	XlinkConfigWriteConfig(3, buf, XLINK_SIZE_17 - 1);
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.XlinkConfigWriteConfig||, CODE, READONLY, ALIGN=1

                  XlinkConfigWriteConfig PROC
;;;64      */
;;;65     static int XlinkConfigWriteConfig(x_int8 *data, unsigned int len) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;66     	//memcpy(buf,data,len);
;;;67     	x_int16 ret = hffile_userbin_write(XLINK_USR_BIN_ADDR_CFG, data, len);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       hffile_userbin_write
000010  b206              SXTH     r6,r0
;;;68     	//int ret = len;
;;;69     	return ret;
000012  4630              MOV      r0,r6
;;;70     }
000014  bd70              POP      {r4-r6,pc}
;;;71     
                          ENDP


                          AREA ||i.XlinkGetDeviceMac||, CODE, READONLY, ALIGN=2

                  XlinkGetDeviceMac PROC
;;;145     */
;;;146    x_int32 XlinkGetDeviceMac(x_uint8 *mac) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
;;;147    	x_int8 buf[20] = { 0x00 };
000008  2114              MOVS     r1,#0x14
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;148    
;;;149    	char *cmd = "AT+WSMAC\r\n";
000010  a714              ADR      r7,|L4.100|
;;;150    	x_int32 ret = hfat_send_cmd(cmd, xlink_strlen(cmd), buf, 20);
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       strlen
000018  4606              MOV      r6,r0
00001a  2314              MOVS     r3,#0x14
00001c  aa01              ADD      r2,sp,#4
00001e  4631              MOV      r1,r6
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       hfat_send_cmd
000026  4680              MOV      r8,r0
;;;151    	x_uint8 index = 4;
000028  2504              MOVS     r5,#4
;;;152    	for (x_uint8 i = 0; i < 6; i++) {
00002a  2600              MOVS     r6,#0
00002c  e013              B        |L4.86|
                  |L4.46|
;;;153    		char h = buf[index++];
00002e  4628              MOV      r0,r5
000030  1c69              ADDS     r1,r5,#1
000032  b2cd              UXTB     r5,r1
000034  a901              ADD      r1,sp,#4
000036  f8119000          LDRB     r9,[r1,r0]
;;;154    		char l = buf[index++];
00003a  4628              MOV      r0,r5
00003c  1c69              ADDS     r1,r5,#1
00003e  b2cd              UXTB     r5,r1
000040  a901              ADD      r1,sp,#4
000042  f811a000          LDRB     r10,[r1,r0]
;;;155    		mac_to_hex(h, l, mac++);
000046  4622              MOV      r2,r4
000048  1c64              ADDS     r4,r4,#1
00004a  4651              MOV      r1,r10
00004c  4648              MOV      r0,r9
00004e  f7fffffe          BL       mac_to_hex
000052  1c70              ADDS     r0,r6,#1              ;152
000054  b2c6              UXTB     r6,r0                 ;152
                  |L4.86|
000056  2e06              CMP      r6,#6                 ;152
000058  dbe9              BLT      |L4.46|
;;;156    	}
;;;157    	return ret - 4;
00005a  f1a80004          SUB      r0,r8,#4
;;;158    }
00005e  b006              ADD      sp,sp,#0x18
000060  e8bd87f0          POP      {r4-r10,pc}
;;;159    
                          ENDP

                  |L4.100|
000064  41542b57          DCB      "AT+WSMAC\r\n",0
000068  534d4143
00006c  0d0a00  
00006f  00                DCB      0

                          AREA ||i.XlinkReadAtConfig||, CODE, READONLY, ALIGN=1

                  XlinkReadAtConfig PROC
;;;99     
;;;100    int XlinkReadAtConfig(AT_CONFIG *config) {
000000  b510              PUSH     {r4,lr}
000002  b08e              SUB      sp,sp,#0x38
000004  4604              MOV      r4,r0
;;;101    	char buf[50];
;;;102    	memset(buf, 0, 50);
000006  2134              MOVS     r1,#0x34
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;103    	hffile_userbin_read(XLINK_USR_BIN_ADDR_AT, buf, 50);
00000e  2232              MOVS     r2,#0x32
000010  a901              ADD      r1,sp,#4
000012  20a4              MOVS     r0,#0xa4
000014  f7fffffe          BL       hffile_userbin_read
;;;104    	config->flag.byte = buf[0];
000018  f89d0004          LDRB     r0,[sp,#4]
00001c  7020              STRB     r0,[r4,#0]
;;;105    	memcpy(config->macString, buf + 1, 12);
00001e  f8dd0005          LDR      r0,[sp,#5]
000022  f8c40001          STR      r0,[r4,#1]
000026  f8dd0009          LDR      r0,[sp,#9]
00002a  f8c40005          STR      r0,[r4,#5]
00002e  f8dd000d          LDR      r0,[sp,#0xd]
000032  f8c40009          STR      r0,[r4,#9]
;;;106    	config->macString[12]='\0';
000036  2100              MOVS     r1,#0
000038  7361              STRB     r1,[r4,#0xd]
;;;107    	return 50;
00003a  2032              MOVS     r0,#0x32
;;;108    }
00003c  b00e              ADD      sp,sp,#0x38
00003e  bd10              POP      {r4,pc}
;;;109    
                          ENDP


                          AREA ||i.XlinkReadProductIDKEY||, CODE, READONLY, ALIGN=1

                  XlinkReadProductIDKEY PROC
;;;81     
;;;82     int XlinkReadProductIDKEY(char *proid, char *proKey) {
000000  b570              PUSH     {r4-r6,lr}
000002  b092              SUB      sp,sp,#0x48
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;83     	int index = XLINK_USR_BIN_ADDR_PDID;
000008  2664              MOVS     r6,#0x64
;;;84     	char product[65];
;;;85     	hffile_userbin_read(index, product, 64);
00000a  2240              MOVS     r2,#0x40
00000c  a901              ADD      r1,sp,#4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       hffile_userbin_read
;;;86     	memcpy(proid, product, 32);
000014  2220              MOVS     r2,#0x20
000016  a901              ADD      r1,sp,#4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       __aeabi_memcpy
;;;87     	memcpy(proKey, product + 32, 32);
00001e  2220              MOVS     r2,#0x20
000020  a909              ADD      r1,sp,#0x24
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       __aeabi_memcpy
;;;88     	return 0;
000028  2000              MOVS     r0,#0
;;;89     }
00002a  b012              ADD      sp,sp,#0x48
00002c  bd70              POP      {r4-r6,pc}
;;;90     
                          ENDP


                          AREA ||i.XlinkWriteAtConfig||, CODE, READONLY, ALIGN=1

                  XlinkWriteAtConfig PROC
;;;90     
;;;91     int XlinkWriteAtConfig(AT_CONFIG *config) {
000000  b510              PUSH     {r4,lr}
000002  b08e              SUB      sp,sp,#0x38
000004  4604              MOV      r4,r0
;;;92     	char buf[50];
;;;93     	memset(buf, 0, 50);
000006  2134              MOVS     r1,#0x34
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;94     	buf[0] = config->flag.byte;
00000e  7820              LDRB     r0,[r4,#0]
000010  f88d0004          STRB     r0,[sp,#4]
;;;95     	memcpy(buf + 1, config->macString, 12);
000014  f8d40001          LDR      r0,[r4,#1]
000018  f8cd0005          STR      r0,[sp,#5]
00001c  f8d40005          LDR      r0,[r4,#5]
000020  f8cd0009          STR      r0,[sp,#9]
000024  f8d40009          LDR      r0,[r4,#9]
000028  f8cd000d          STR      r0,[sp,#0xd]
;;;96     	hffile_userbin_write(XLINK_USR_BIN_ADDR_AT, buf, 50);
00002c  2232              MOVS     r2,#0x32
00002e  a901              ADD      r1,sp,#4
000030  20a4              MOVS     r0,#0xa4
000032  f7fffffe          BL       hffile_userbin_write
;;;97     	return 50;
000036  2032              MOVS     r0,#0x32
;;;98     }
000038  b00e              ADD      sp,sp,#0x38
00003a  bd10              POP      {r4,pc}
;;;99     
                          ENDP


                          AREA ||i.XlinkWriteProductIDKEY||, CODE, READONLY, ALIGN=1

                  XlinkWriteProductIDKEY PROC
;;;71     
;;;72     int XlinkWriteProductIDKEY(char *proid, char *proKey) {
000000  b570              PUSH     {r4-r6,lr}
000002  b092              SUB      sp,sp,#0x48
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;73     	int index = XLINK_USR_BIN_ADDR_PDID;
000008  2664              MOVS     r6,#0x64
;;;74     	char product[65];
;;;75     	memset(product, 0, 64);
00000a  2140              MOVS     r1,#0x40
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       __aeabi_memclr4
;;;76     	memcpy(product, proid, 32);
000012  2220              MOVS     r2,#0x20
000014  4621              MOV      r1,r4
000016  a801              ADD      r0,sp,#4
000018  f7fffffe          BL       __aeabi_memcpy
;;;77     	memcpy(product + 32, proKey, 32);
00001c  2220              MOVS     r2,#0x20
00001e  4629              MOV      r1,r5
000020  a809              ADD      r0,sp,#0x24
000022  f7fffffe          BL       __aeabi_memcpy
;;;78     	hffile_userbin_write(index, product, 64);
000026  2240              MOVS     r2,#0x40
000028  a901              ADD      r1,sp,#4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       hffile_userbin_write
;;;79     	return 0;
000030  2000              MOVS     r0,#0
;;;80     }
000032  b012              ADD      sp,sp,#0x48
000034  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP


                          AREA ||i.mac_to_hex||, CODE, READONLY, ALIGN=1

                  mac_to_hex PROC
;;;120     */
;;;121    XLINK_FUNC void mac_to_hex(char ch_h, char ch_l, x_uint8 *for_num) {
000000  b530              PUSH     {r4,r5,lr}
000002  4613              MOV      r3,r2
;;;122    	int t = 0;
000004  2200              MOVS     r2,#0
;;;123    	int int_data = 0;
000006  2400              MOVS     r4,#0
;;;124    	if (ch_h <= '9') {
000008  2839              CMP      r0,#0x39
00000a  dc02              BGT      |L9.18|
;;;125    		t = ch_h - '0';
00000c  f1a00230          SUB      r2,r0,#0x30
000010  e001              B        |L9.22|
                  |L9.18|
;;;126    	} else {
;;;127    		t = ch_h - 'A' + 10;
000012  f1a00237          SUB      r2,r0,#0x37
                  |L9.22|
;;;128    	}
;;;129    	if (ch_l <= '9') {
000016  2939              CMP      r1,#0x39
000018  dc04              BGT      |L9.36|
;;;130    		int_data = t * 16 + (ch_l - '0');
00001a  f1a10530          SUB      r5,r1,#0x30
00001e  eb051402          ADD      r4,r5,r2,LSL #4
000022  e003              B        |L9.44|
                  |L9.36|
;;;131    	} else {
;;;132    		int_data = t * 16 + (ch_l - 'A' + 10);
000024  f1a10537          SUB      r5,r1,#0x37
000028  eb051402          ADD      r4,r5,r2,LSL #4
                  |L9.44|
;;;133    	}
;;;134    	*for_num = (unsigned char) int_data;
00002c  701c              STRB     r4,[r3,#0]
;;;135    }
00002e  bd30              POP      {r4,r5,pc}
;;;136    
                          ENDP


                          AREA ||i.xlinkConfigInit||, CODE, READONLY, ALIGN=2

                  xlinkConfigInit PROC
;;;27     //char buf[120];
;;;28     void xlinkConfigInit(XLINK_USER_CONFIG *config) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;29     	config->readConfig = XlinkConfigReadConfig;
000004  4804              LDR      r0,|L10.24|
000006  6120              STR      r0,[r4,#0x10]
;;;30     	config->writeConfig = XlinkConfigWriteConfig;
000008  4804              LDR      r0,|L10.28|
00000a  60e0              STR      r0,[r4,#0xc]
;;;31     	XlinkGetDeviceMac(config->mac);
00000c  f1040030          ADD      r0,r4,#0x30
000010  f7fffffe          BL       XlinkGetDeviceMac
;;;32     
;;;33     	//memset(buf,0,120);
;;;34     }
000014  bd10              POP      {r4,pc}
;;;35     
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      XlinkConfigReadConfig
                  |L10.28|
                          DCD      XlinkConfigWriteConfig
